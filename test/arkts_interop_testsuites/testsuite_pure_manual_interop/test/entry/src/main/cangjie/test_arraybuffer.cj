/*
 * Copyright (c) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package ohos_app_cangjie_entry

import std.unittest.*
import std.unittest.testmacro.*
import ohos.ark_interop.*

@Test
class TestArrayBuffer {
    @TestCase
    func testJSArrayBufferToUInt8Array() {
        let jsContext = getJSContext()
        let data: Array<UInt8> = [0, 255, 128, 64, 32]
        let buffer = await(jsContext) {jsContext.arrayBuffer(data)}
        let result = await(jsContext) {buffer.toUInt8Array()}

        @Expect(await(jsContext){buffer.toJSValue().isArrayBuffer()}, true)

        @Expect(result.size, data.size) //判断接口功能是否正确，优先
        for (i in 0..result.size) { //然后才是覆盖率
            @Expect(result[i], data[i])
        }
    }

    @TestCase
    func testJSArrayBufferToInt8Array() {
        let jsContext = getJSContext()
        let data: Array<Int8> = [-128, -64, 0, 64, 127]
        let buffer = await(jsContext) {jsContext.arrayBuffer(data)}
        let result = await(jsContext) {buffer.toInt8Array()}

        @Expect(await(jsContext){buffer.toJSValue().isArrayBuffer()}, true)

        @Expect(result.size, data.size)
        for (i in 0..result.size) {
            @Expect(result[i], data[i])
        }
    }

    @TestCase
    func testJSArrayBufferToUInt16Array() {
        let jsContext = getJSContext()
        let data: Array<UInt16> = [0, 65535, 32768, 12345]
        let buffer = await(jsContext) {jsContext.arrayBuffer(data)}
        let result = await(jsContext) {buffer.toUInt16Array()}

        @Expect(await(jsContext){buffer.toJSValue().isArrayBuffer()}, true)

        @Expect(result.size, data.size)
        for (i in 0..result.size) {
            @Expect(result[i], data[i])
        }
    }

    @TestCase
    func testJSArrayBufferToInt16Array() {
        let jsContext = getJSContext()
        let data: Array<Int16> = [-32768, -12345, 0, 12345, 32767]
        let buffer = await(jsContext) {jsContext.arrayBuffer(data)}
        let result = await(jsContext) {buffer.toInt16Array()}

        @Expect(await(jsContext){buffer.toJSValue().isArrayBuffer()}, true)

        @Expect(result.size, data.size)
        for (i in 0..result.size) {
            @Expect(result[i], data[i])
        }
    }

    @TestCase
    func testJSArrayBufferToInt32Array() {
        let jsContext = getJSContext()
        let data: Array<Int32> = [-2147483648, -1000000000, 0, 1000000000, 2147483647]
        let buffer = await(jsContext) {jsContext.arrayBuffer(data)}
        let result = await(jsContext) {buffer.toInt32Array()}

        @Expect(await(jsContext){buffer.toJSValue().isArrayBuffer()}, true)

        @Expect(result.size, data.size)
        for (i in 0..result.size) {
            @Expect(result[i], data[i])
        }
    }

    @TestCase
    func testJSArrayBufferToUInt32Array() {
        let jsContext = getJSContext()
        let data: Array<UInt32> = [0, 4294967295, 2147483648, 1234567890]
        let buffer = await(jsContext) {jsContext.arrayBuffer(data)}
        let result = await(jsContext) {buffer.toUInt32Array()}

        @Expect(await(jsContext){buffer.toJSValue().isArrayBuffer()}, true)

        @Expect(result.size, data.size)
        for (i in 0..result.size) {
            @Expect(result[i], data[i])
        }
    }

    @TestCase
    func testJSArrayBufferToFloat32Array() {
        let jsContext = getJSContext()
        let data: Array<Float32> = [0.0, 3.14, -1.23, 1.23, 99999.999]
        let buffer = await(jsContext) {jsContext.arrayBuffer(data)}
        let result = await(jsContext) {buffer.toFloat32Array()}

        @Expect(await(jsContext){buffer.toJSValue().isArrayBuffer()}, true)

        @Expect(result.size, data.size)
        for (i in 0..result.size) {
            @Expect(result[i], data[i])
        }
    }

    @TestCase
    func testJSArrayBufferToInt64Array() {
        let jsContext = getJSContext()
        let data: Array<Int64> = [-9223372036854775808, -1000000000, 9223372036854775807, 1234567890123456]
        let buffer = await(jsContext) {jsContext.arrayBuffer(data)}
        let result = await(jsContext) {buffer.toInt64Array()}

        @Expect(await(jsContext){buffer.toJSValue().isArrayBuffer()}, true)

        @Expect(result.size, data.size)
        for (i in 0..result.size) {
            @Expect(result[i], data[i])
        }
    }

    @TestCase
    func testJSArrayBufferToFloat64() {
        let jsContext = getJSContext()
        let data: Array<Float64> = [-9223372036854775808.0, -1000000000.0, 9223372036854775807.0, 1234567890123456.0]
        let buffer = await(jsContext) {jsContext.arrayBuffer(data)}
        let result = await(jsContext) {buffer.toFloat64Array()}

        @Expect(await(jsContext){buffer.toJSValue().isArrayBuffer()}, true)

        @Expect(result.size, data.size)
        for (i in 0..result.size) {
            @Expect(result[i], data[i])
        }
    }

    @TestCase
    func testJSArrayBufferToArrayBuffer() {
        let jsContext = getJSContext()
        let data: Array<UInt8> = [0, 255, 128, 64, 32]
        let buffer = await(jsContext) {jsContext.arrayBuffer(data)}
        let result = await(jsContext) {buffer.toArrayBufferJSValue()}

        @Expect(await(jsContext){result.isArrayBuffer()}, true)
        @Expect(isInstanceOf(jsContext, result, "ArrayBuffer"))
    }

    @TestCase
    func testToUInt8ArrayJSValueHandler() {
        let jsContext = getJSContext()
        let data: Array<UInt8> = [0, 255, 128, 64, 32]
        let buffer = await(jsContext) {jsContext.arrayBuffer(data)}
        let result = await(jsContext) {buffer.toUInt8ArrayJSValue()}

        @Expect(await(jsContext){result.isArrayBuffer()}, true)
        @Expect(isInstanceOf(jsContext, result, "Uint8Array"))
    }

    @TestCase
    func testToUInt8ClampedArray() {
        let jsContext = getJSContext()
        let data: Array<UInt8> = [0, 255, 128, 64, 32]
        let buffer = await(jsContext) {jsContext.arrayBuffer(data)}
        let result = await(jsContext) {buffer.toUInt8ClampedArrayJSValue()}

        @Expect(await(jsContext){result.isArrayBuffer()}, true)
        @Expect(isInstanceOf(jsContext, result, "Uint8ClampedArray"))
    }

    @TestCase
    func testToInt8ArrayJSValueHandler() {
        let jsContext = getJSContext()
        let data: Array<Int8> = [-128, -64, 0, 64, 127]
        let buffer = await(jsContext) {jsContext.arrayBuffer(data)}
        let result = await(jsContext) {buffer.toInt8ArrayJSValue()}

        @Expect(await(jsContext){result.isArrayBuffer()}, true)
        @Expect(isInstanceOf(jsContext, result, "Int8Array"))
    }

    @TestCase
    func testToUInt16ArrayJSValueHandler() {
        let jsContext = getJSContext()
        let data: Array<UInt16> = [0, 65535, 32768, 12345]
        let buffer = await(jsContext) {jsContext.arrayBuffer(data)}
        let result = await(jsContext) {buffer.toUInt16ArrayJSValue()}

        @Expect(await(jsContext){result.isArrayBuffer()}, true)
        @Expect(isInstanceOf(jsContext, result, "Uint16Array"))
    }

    @TestCase
    func testToInt16ArrayJSValueHandler() {
        let jsContext = getJSContext()
        let data: Array<Int16> = [-32768, -12345, 0, 12345, 32767]
        let buffer = await(jsContext) {jsContext.arrayBuffer(data)}
        let result = await(jsContext) {buffer.toInt16ArrayJSValue()}

        @Expect(await(jsContext){result.isArrayBuffer()}, true)
        @Expect(isInstanceOf(jsContext, result, "Int16Array"))
    }

    @TestCase
    func testToInt32ArrayJSValueHandler() {
        let jsContext = getJSContext()
        let data: Array<Int32> = [-2147483648, -1000000000, 0, 1000000000, 2147483647]
        let buffer = await(jsContext) {jsContext.arrayBuffer(data)}
        let result = await(jsContext) {buffer.toInt32ArrayJSValue()}

        @Expect(await(jsContext){result.isArrayBuffer()}, true)
        @Expect(isInstanceOf(jsContext, result, "Int32Array"))
    }

    @TestCase
    func testToUInt32ArrayJSValueHandler() {
        let jsContext = getJSContext()
        let data: Array<UInt32> = [0, 4294967295, 2147483648, 1234567890]
        let buffer = await(jsContext) {jsContext.arrayBuffer(data)}
        let result = await(jsContext) {buffer.toUInt32ArrayJSValue()}

        @Expect(await(jsContext){result.isArrayBuffer()}, true)
        @Expect(isInstanceOf(jsContext, result, "Uint32Array"))
    }

    @TestCase
    func testToFloat32ArrayJSValueHandler() {
        let jsContext = getJSContext()
        let data: Array<Float32> = [0.0, 3.14, -1.23, 1.23, 99999.999]
        let buffer = await(jsContext) {jsContext.arrayBuffer(data)}
        let result = await(jsContext) {buffer.toFloat32ArrayJSValue()}

        @Expect(await(jsContext){result.isArrayBuffer()}, true)
        @Expect(isInstanceOf(jsContext, result, "Float32Array"))
    }

    @TestCase
    func testToFloat64ArrayJSValueHandler() {
        let jsContext = getJSContext()
        let data: Array<Float64> = [0.0, 3.1415926535, -123456.789, 9999999.888]
        let buffer = await(jsContext) {jsContext.arrayBuffer(data)}
        let result = await(jsContext) {buffer.toFloat64ArrayJSValue()}

        @Expect(await(jsContext){result.isArrayBuffer()}, true)
        @Expect(isInstanceOf(jsContext, result, "Float64Array"))
    }

    @TestCase
    func testToInt64ArrayJSValueHandler() {
        let jsContext = getJSContext()
        let data: Array<Int64> = [-223372036854775808, 1000000000, 9223372036854775807, -1234567890123456]
        let buffer = await(jsContext) {jsContext.arrayBuffer(data)}
        let result = await(jsContext) {buffer.toInt64ArrayJSValue()}

        @Expect(await(jsContext){result.isArrayBuffer()}, true)
        @Expect(isInstanceOf(jsContext, result, "BigInt64Array"))
    }

    @TestCase
    func testToUInt64ArrayJSValueHandler() {
        let jsContext = getJSContext()
        let data: Array<UInt64> = [9223372036854775808, 1000000000, 9223372036854775807, 1234567890123456]
        let buffer = await(jsContext) {jsContext.arrayBuffer(data)}
        let result = await(jsContext) {buffer.toUInt64ArrayJSValue()}

        @Expect(await(jsContext){result.isArrayBuffer()}, true)
        @Expect(isInstanceOf(jsContext, result, "BigUint64Array"))
    }

    @TestCase
    func testArrayBufferBytes() {
        let jsContext = getJSContext()
        let source: Array<Byte> = [0, 1, 2, 3, 4]
        let buffer = await(jsContext) {jsContext.arrayBuffer(source)}
        @Expect(Int64(await(jsContext){buffer.byteLength}), source.size)
        @Expect(Int64(await(jsContext){buffer.byteLength}), source.size)
        let received = await(jsContext) {buffer.readBytes()}
        await(jsContext) {buffer.readBytes()}
        @Expect(source, received)
    }

    @TestCase
    func testArrayBufferUnsafe() {
        let jsContext = getJSContext()
        let source: CPointer<Byte> = unsafe {
            let result = LibC.malloc<Byte>(count: 100)
            for (i in 0..100) {
                unsafe { result.write(i, UInt8(i)) }
            }
            result
        }

        let buffer = await(jsContext) {
            unsafe {
                jsContext.arrayBuffer(source, 100, {
                    ptr => LibC.free(ptr)
                })
            }
        }

        @Expect(await(jsContext){buffer.byteLength}, 100)
        let data = await(jsContext) {buffer.readBytes()}
        for (i in 0..100) {
            @Expect(data[i], UInt8(i))
        }
    }
}

func isInstanceOf(jsContext: JSContext, value: JSValue, className: String): Bool {
    if (await(jsContext) {!value.isObject()}) {
        println("target is not object")
        return false
    }
    let object = await(jsContext) {value.asObject()}
    let classValue = await(jsContext) {jsContext.global[className]}
    if (!await(jsContext) {classValue.isClass()}) {
        println("target class not exist: '${className}'")
        return false
    }
    await(jsContext) {object.instanceOf(classValue.asClass())}
}
