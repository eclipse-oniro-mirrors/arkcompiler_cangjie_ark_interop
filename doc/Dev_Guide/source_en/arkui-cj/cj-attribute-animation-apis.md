# Implementing Property Animations

Continuous visual effects on the UI caused by changes to animatable properties are referred to as property animations. Property animations are the most fundamental and easy-to-understand animations. ArkUI provides two property animation interfaces: [animateTo](../../../API_Reference/source_en/arkui-cj/cj-animation-animateto.md) and [animation](../../../API_Reference/source_en/arkui-cj/cj-animation-animation.md), which drive component properties to change continuously according to animation curves and other animation parameters, thereby generating property animations.

| Property Animation Interface | Scope | Principle | Use Case |
|:---|:---|:---|:---|
| animateTo | Changes in the UI caused by property modifications within a closure.<br/>Applies to appear/disappear transitions. | A general-purpose function that animates the differences between the pre-closure UI and the UI resulting from state variable changes within the closure.<br/>Supports multiple calls and nesting. | Suitable for configuring the same animation parameters for multiple animatable properties.<br/>Scenarios requiring nested animations. |
| animation | Changes in the UI caused by property changes bound through component property interfaces. | Detects changes to animatable properties of components and automatically applies animations.<br/>Component interface calls execute from bottom to top, and `animation` only affects property calls above it. Components can set different `animation` parameters for multiple properties based on the call order. | Suitable for configuring different animation parameters for multiple animatable properties. |

## Using animateTo to Generate Property Animations

```cangjie
public func animateTo(animation: AnimateParam, callback: () -> Unit): Unit
```

In the [animateTo](../../../API_Reference/source_en/arkui-cj/cj-animation-animateto.md) interface parameters, `animation` specifies an [AnimateParam object](../../../API_Reference/source_en/arkui-cj/cj-animation-animateto.md#struct-animateparam) (including duration, [Curve](../../../API_Reference/source_en/arkui-cj/cj-common-types.md#enum-curve), etc.), and `callback` is the closure function for the animation. Property animations generated by variable changes within the closure will follow the same animation parameters.

 <!-- run -->

```cangjie
package ohos_app_cangjie_entry
import kit.ArkUI.*
import ohos.arkui.ui_context.*
import ohos.arkui.state_macro_manage.*

@Entry
@Component
class EntryView {
    @State var animate: Bool = false
    // Step 1: Declare relevant state variables
    @State var rotateValue: Float32 = 0.0
    @State var translateX: Float32 = 0.0
    @State var opacityValue: Float32 = 1.0

    // Step 2: Apply state variables to relevant animatable property interfaces
    func build() {
        Row {
            // Component 1
            Column {
            }
            .rotate(angle:this.rotateValue)
            .backgroundColor(0x317AF7)
            .justifyContent(FlexAlign.Center)
            .width(100.vp)
            .height(100.vp)
            .borderRadius(30.vp)
            .onClick{ evt =>
                    getUIContext().animateTo(AnimateParam(curve: Curve.Smooth),
                    { =>
                        this.animate = !this.animate
                        // Step 3: Modify the UI through state variable changes within the closure
                        // Any logic that changes the UI can be written here, such as array operations or visibility control. The system will detect differences between the pre- and post-change UI and apply animations to the changed parts.
                        // The rotate property of Component 1 changes, so a rotate animation will be applied to Component 1.
                        if (this.animate) {
                            this.rotateValue = 90.0
                        } else {
                            this.rotateValue = 0.0
                        }
                        // The opacity of Component 2 changes, so an opacity animation will be applied to Component 2.
                        if (this.animate) {
                            this.opacityValue = 0.6
                        } else {
                            this.opacityValue = 1.0
                        }
                        // The translate property of Component 2 changes, so a translate animation will be applied to Component 2.
                        if (this.animate) {
                            this.translateX = 50.0
                        } else {
                            this.translateX = 0.0
                        }
                    })
            }

            // Component 2
            Column {
            }
            .justifyContent(FlexAlign.Center)
            .width(100.vp)
            .height(100.vp)
            .backgroundColor(0xD94838)
            .borderRadius(30.vp)
            .opacity(Float64(this.opacityValue))
            .translate(x: Float64(this.translateX))
        }
        .width(100.percent)
        .height(100.percent)
        .justifyContent(FlexAlign.Center)
    }
}
```

![animation5](./figures/animation5.gif)

## Using animation to Generate Property Animations

Unlike the `animateTo` interface, which requires property modifications to be placed within a closure, the [animationStart](../../../API_Reference/source_en/arkui-cj/cj-animation-animation.md#func-animationstart) and [animationEnd](../../../API_Reference/source_en/arkui-cj/cj-animation-animation.md#func-animationend) interfaces do not require a closure. Simply place `animationStart` on the first property of the component and `animationEnd` on the last property. `animationStart` and `animationEnd` automatically apply property animations when they detect changes to their bound animatable properties, whereas `animateTo` requires animatable property values to be modified within the animation closure to generate animations.

 <!-- run -->

```cangjie
package ohos_app_cangjie_entry
import kit.ArkUI.*
import ohos.arkui.state_macro_manage.*

@Entry
@Component
class EntryView {
    @State var animate: Bool = false
    // Step 1: Declare relevant state variables
    @State var rotateValue: Float32 = 0.0
    @State var translateX: Float32 = 0.0
    @State var opacityValue: Float32 = 1.0

    // Step 2: Apply state variables to relevant animatable property interfaces
    func build() {
        Row {
            // Component 1
            Column {
            }
            .animationStart(AnimateParam(curve: Curve.Smooth))
            .opacity(Float64(this.opacityValue))
            .rotate(angle:this.rotateValue)
            .backgroundColor(0x317AF7)
            .justifyContent(FlexAlign.Center)
            .width(100.vp)
            .height(100.vp)
            .borderRadius(30.vp)
            .onClick{ evt=>
                    this.animate = !this.animate
                    if (this.animate) {
                        this.rotateValue = 90.0
                    } else {
                        this.rotateValue = 0.0
                    }
                    if (this.animate) {
                        this.opacityValue = 0.6
                    } else {
                        this.opacityValue = 1.0
                    }
                    if (this.animate) {
                        this.translateX = 50.0
                    } else {
                        this.translateX = 0.0
                    }
            }
            .animationEnd()

            // Component 2
            Column {
            }
            .animationStart(AnimateParam(curve: Curve.Smooth))
            .justifyContent(FlexAlign.Center)
            .width(100.vp)
            .height(100.vp)
            .backgroundColor(0xD94838)
            .borderRadius(30.vp)
            .opacity(Float64(this.opacityValue))
            .translate(x: Float64(this.translateX))
            .animationEnd()
        }.width(100.percent).height(100.percent).justifyContent(FlexAlign.Center)
    }
}
```

![animation6](./figures/animation6.gif)

> **Notes:**
>
> - When animating changes to a component's position or size, layout property changes trigger measurement and layout, which incur significant performance overhead. Changes to the [scale](../../../API_Reference/source_en/arkui-cj/cj-universal-attribute-transform.md#func-scalefloat32-float32-float32-length-length) property do not trigger measurement and layout, resulting in lower overhead. Therefore, for scenarios where a component's position or size changes continuously (e.g., resizing triggered by touch), using `scale` is recommended.
>
> - Property animations should be applied to components that always exist. For animations involving components that are about to appear or disappear, use [transition animations](./cj-transition-overview.md).
>
> - Avoid using animation end callbacks whenever possible. Property animations animate existing state changes and do not require developers to handle end logic. If end callbacks must be used, ensure proper data management for continuous operations.