# Implementing Property Animation

Property animation refers to the continuous visual effects produced on the UI through changes in animatable properties. As the most fundamental and easy-to-understand type of animation, ArkUI provides two property animation interfaces: [animateTo](../../../API_Reference/source_zh_cn/arkui-cj/cj-animation-animateto.md) and [animation](../../../API_Reference/source_zh_cn/arkui-cj/cj-animation-animation.md). These interfaces drive component properties to change continuously according to animation curves and other animation parameters, thereby generating property animations.

| Property Animation Interface | Scope | Principle | Use Cases |
|:---|:---|:---|:---|
| animateTo | Changes in the interface caused by property modifications within a closure.<br/>Applies to appear/disappear transitions. | A general function that animates the differences between the pre-closure interface and the interface caused by state variables within the closure.<br/>Supports multiple calls and nesting. | Suitable for animations where multiple animatable properties share the same animation parameters.<br/>Scenarios requiring nested animations. |
| animation | Interface changes caused by property changes bound through component property interfaces. | Detects changes in animatable properties of components and automatically adds animations.<br/>Component interface calls execute from bottom to top, so `animation` only affects property calls above it. Components can set different `animation` parameters for multiple properties based on call order. | Suitable for scenarios where different animation parameters are configured for multiple animatable properties. |

## Using animateTo to Generate Property Animation

```cangjie
public func animateTo(animation: AnimateParam, callback: () -> Unit): Unit
```

In the parameters of the [animateTo](../../../API_Reference/source_zh_cn/arkui-cj/cj-animation-animateto.md) interface, `animation` specifies an [AnimateParam object](../../../API_Reference/source_zh_cn/arkui-cj/cj-animation-animateto.md#struct-animateparam) (including duration, [Curve](../../../API_Reference/source_zh_cn/arkui-cj/cj-common-types.md#enum-curve), etc.), and `callback` is the closure function for the animation. Property animations generated by variable changes within the closure will follow the same animation parameters.

<!-- run -->

```cangjie
package ohos_app_cangjie_entry
import kit.ArkUI.*
import ohos.arkui.state_macro_manage.*

@Entry
@Component
class EntryView {
    @State var animate: Bool = false
    // Step 1: Declare relevant state variables
    @State var rotateValue: Float32 = 0.0
    @State var translateX: Float32 = 0.0
    @State var opacityValue: Float32 = 1.0

    // Step 2: Apply state variables to relevant animatable property interfaces
    func build() {
        Row {
            // Component 1
            Column {
            }
            .rotate(this.rotateValue)
            .backgroundColor(0x317AF7)
            .justifyContent(FlexAlign.Center)
            .width(100.vp)
            .height(100.vp)
            .borderRadius(30.vp)
            .onClick{ evt =>
                    animateTo(AnimateParam(curve: Curve.Smooth),
                    { =>
                        this.animate = !this.animate
                        // Step 3: Modify the UI interface through state variables within the closure
                        // Any logic that changes the UI (e.g., array operations, visibility control) can be written here. The system detects differences between the pre- and post-change UI and adds animations to the changed parts.
                        // The rotate property of Component 1 changes, so a rotate animation will be applied to Component 1.
                        if (this.animate) {
                            this.rotateValue = 90.0
                        } else {
                            this.rotateValue = 0.0
                        }
                        // The opacity of Component 2 changes, so an opacity animation will be applied to Component 2.
                        if (this.animate) {
                            this.opacityValue = 0.6
                        } else {
                            this.opacityValue = 1.0
                        }
                        // The translate property of Component 2 changes, so a translate animation will be applied to Component 2.
                        if (this.animate) {
                            this.translateX = 50.0
                        } else {
                            this.translateX = 0.0
                        }
                    })
            }

            // Component 2
            Column {
            }
            .justifyContent(FlexAlign.Center)
            .width(100.vp)
            .height(100.vp)
            .backgroundColor(0xD94838)
            .borderRadius(30.vp)
            .opacity(Float64(this.opacityValue))
            .translate(x: Float64(this.translateX))
        }
        .width(100.percent)
        .height(100.percent)
        .justifyContent(FlexAlign.Center)
    }
}
```

![animation5](./figures/animation5.gif)

## Using animation to Generate Property Animation

Unlike the `animateTo` interface, which requires property modifications to be placed within a closure, the [animationStart](../../../API_Reference/source_zh_cn/arkui-cj/cj-animation-animation.md#func-animationstart) and [animationEnd](../../../API_Reference/source_zh_cn/arkui-cj/cj-animation-animation.md#func-animationend) interfaces do not require a closure. Simply place `animationStart` on the first property of the component and `animationEnd` on the last property. `animationStart` and `animationEnd` automatically add property animations when they detect changes in their bound animatable properties, whereas `animateTo` requires animatable property values to be modified within the animation closure to generate animations.

<!-- run -->

```cangjie
package ohos_app_cangjie_entry
import kit.ArkUI.*
import ohos.arkui.state_macro_manage.*

@Entry
@Component
class EntryView {
    @State var animate: Bool = false
    // Step 1: Declare relevant state variables
    @State var rotateValue: Float32 = 0.0
    @State var translateX: Float32 = 0.0
    @State var opacityValue: Float32 = 1.0

    // Step 2: Apply state variables to relevant animatable property interfaces
    func build() {
        Row {
            // Component 1
            Column {
            }
            .animationStart(AnimateParam(curve: Curve.Smooth))
            .opacity(Float64(this.opacityValue))
            .rotate(this.rotateValue)
            .backgroundColor(0x317AF7)
            .justifyContent(FlexAlign.Center)
            .width(100.vp)
            .height(100.vp)
            .borderRadius(30.vp)
            .onClick{ evt=>
                    this.animate = !this.animate
                    if (this.animate) {
                        this.rotateValue = 90.0
                    } else {
                        this.rotateValue = 0.0
                    }
                    if (this.animate) {
                        this.opacityValue = 0.6
                    } else {
                        this.opacityValue = 1.0
                    }
                    if (this.animate) {
                        this.translateX = 50.0
                    } else {
                        this.translateX = 0.0
                    }
            }
            .animationEnd()

            // Component 2
            Column {
            }
            .animationStart(AnimateParam(curve: Curve.Smooth))
            .justifyContent(FlexAlign.Center)
            .width(100.vp)
            .height(100.vp)
            .backgroundColor(0xD94838)
            .borderRadius(30.vp)
            .opacity(Float64(this.opacityValue))
            .translate(x: Float64(this.translateX))
            .animationEnd()
        }.width(100.percent).height(100.percent).justifyContent(FlexAlign.Center)
    }
}
```

![animation6](./figures/animation6.gif)

> **Notes:**
>
> - When animating changes in a component's position or size, layout property changes trigger measurement and layout, which incur significant performance overhead. Changes to the [scale](../../../API_Reference/source_zh_cn/arkui-cj/cj-universal-attribute-transform.md#func-scalefloat32-float32-float32-length-length) property do not trigger measurement and layout, resulting in lower performance overhead. Therefore, for scenarios where a component's position or size changes continuously (e.g., drag-and-resize interactions), using `scale` is recommended.
>
> - Property animations should be applied to components that always exist. For components that are about to appear or disappear, use [transition animations](./cj-transition-overview.md).
>
> - Avoid using animation end callbacks whenever possible. Property animations are applied to already occurred states and do not require developers to handle end logic. If end callbacks must be used, ensure proper data management for continuous operations.