# Conditional Compilation

Developers can achieve conditional compilation through predefined or custom conditions; Cangjie currently supports conditional compilation for imports and declarations.

## Conditional Compilation for Imports and Declarations

Cangjie supports using the built-in compilation marker `@When` for conditional compilation. Compilation conditions are enclosed in `[]`, which can contain one or multiple sets of compilation conditions. `@When` can be applied to import nodes and declaration nodes (except `package`).

### Usage

Taking the built-in `os` compilation condition as an example, its usage is as follows:

<!-- run -->

```cangjie
@When[os == "Linux"]
class mc{}

main(): Int64 {
    var a = mc()
    return 0
}
```

In the above code, developers can compile and execute successfully on `Linux` systems; on `non-Linux` systems, they will encounter a compilation error indicating the `mc` class definition cannot be found.

Notably:

- Cangjie does not support nested compilation conditions. The following syntax is prohibited:

    ```cangjie
    @When[os == "Windows"]
    @When[os == "Linux"]    // Error, illegal nested when conditional compilation
    import std.ast.*
    @When[os == "Windows"]
    @When[os == "Linux"]    // Error, illegal nested when conditional compilation
    func A(){}
    ```

- `@When[...]` is a built-in compilation marker processed before imports. If code generated by macro expansion contains `@When[...]`, it will result in a compilation error, e.g.:

    ```cangjie
    @M0                     // macro which returns the input
    @When[os == "Linux"]    // Error, unexpected when conditional compilation directive
    func A(){}
    ```

## Built-in Compilation Condition Variables

Cangjie provides the following built-in condition variables: `os`, `backend`, `arch`, `cjc_version`, `debug`, and `test`.

### os

`os` represents the target platform's operating system. It supports the `==` and `!=` operators. Supported operating systems include: `Windows`, `Linux`, `macOS`.

Usage example:

<!-- run -->

```cangjie
@When[os == "Linux"]
func foo() {
    print("Linux, ")
}
@When[os == "Windows"]
func foo() {
    print("Windows, ")
}
@When[os != "Windows"]
func fee() {
    println("NOT Windows")
}
@When[os != "Linux"]
func fee() {
    println("NOT Linux")
}
main() {
    foo()
    fee()
}
```

When compiled and executed in a `Windows` environment, the output will be `Windows, NOT Linux`; in a `Linux` environment, it will be `Linux, NOT Windows`.

### backend

`backend` represents the target platform's backend type, supporting conditional compilation for multiple backends. It supports the `==` and `!=` operators.

Currently supported backends: `cjnative`.

Usage example:

<!-- run -->

```cangjie
@When[backend == "cjnative"]
func foo() {
    print("cjnative backend")
}
@When[backend != "cjnative"]
func foo() {
    print("not cjnative backend")
}
main() {
    foo()
}
```

When compiled and executed with the `cjnative` backend package, the output will be `cjnative backend`.

### arch

`arch` represents the target platform's processor architecture. It supports the `==` and `!=` operators.

Supported architectures: `x86_64`, `aarch64`.

Usage example:

<!-- run -->

```cangjie
@When[arch == "aarch64"]
var arch = "aarch64"

@When[arch == "x86_64"]
var arch = "x86_64"

main() {
    println(arch)
}
```

When compiled and executed on an `x86_64` architecture platform, the output will be `x86_64`; on an `aarch64` architecture platform, it will be `aarch64`.

### cjc_version

`cjc_version` is a built-in condition allowing developers to select code based on the current Cangjie compiler version. It supports six operators: `==`, `!=`, `>`, `<`, `>=`, `<=`. The format is `xx.xx.xx`, where each `xx` supports 1-2 digits. The comparison rule pads each component to 2 digits, e.g., `0.18.8 < 0.18.11`, `0.18.8 == 0.18.08`.

Usage example:

<!-- run -->

```cangjie
@When[cjc_version == "0.18.6"]
func foo() {
    println("cjc_version equals 0.18.6")
}
@When[cjc_version != "0.18.6"]
func foo() {
    println("cjc_version is NOT equal to 0.18.6")
}
@When[cjc_version > "0.18.6"]
func fnn() {
    println("cjc_version is greater than 0.18.6")
}
@When[cjc_version <= "0.18.6"]
func fnn() {
    println("cjc_version is less than or equal to 0.18.6")
}
@When[cjc_version < "0.18.6"]
func fee() {
    println("cjc_version is less than 0.18.6")
}
@When[cjc_version >= "0.18.6"]
func fee() {
    println("cjc_version is greater than or equal to 0.18.6")
}
main() {
    foo()
    fnn()
    fee()
}
```

The output will vary depending on the `cjc` version.

### debug

`debug` indicates whether debug mode is enabled (via the `-g` compilation option), allowing switching between debug and release builds. It only supports the logical NOT operator (`!`).

Usage example:

<!-- run -->

```cangjie
@When[debug]
func foo() {
    println("debug")
}
@When[!debug]
func foo() {
    println("NOT debug")
}
main() {
    foo()
}
```

When compiled with `-g`, the output will be `debug`; without `-g`, it will be `NOT debug`.

### test

`test` indicates whether unit testing is enabled (via the `--test` option). It only supports the logical NOT operator (`!`), useful for distinguishing test code from regular code.

Usage example:

<!-- run -->

```cangjie
@When[test]
@Test
class Tests {
    @TestCase
    public func case1(): Unit {
        @Expect("run", foo())
    }
}

func foo() {
    "run"
}

@When[!test]
main () {
    println(foo())
}
```

When compiled with `--test`, the test results will be obtained; without `--test`, it will compile and run normally, outputting `run`.

## Custom Compilation Condition Variables

Cangjie allows developers to define custom compilation condition variables and values. Custom condition variables must be valid identifiers and cannot share names with built-in condition variables. Their values are string literals. Custom conditions support the `==` and `!=` operators. Unlike built-in variables, custom conditions must be defined via the `--cfg` compilation option or in the `cfg.toml` configuration file.

### Configuring Custom Condition Variables

There are two ways to configure custom condition variables: directly via compilation options or through a configuration file.

Developers can use `--cfg <value>` to pass custom compilation condition variables as key-value pairs or specify the search path for the `cfg.toml` configuration file.

- Option values must be enclosed in double quotes.

- If the option value contains `=`, it will be treated as a key-value pair (if the path contains `=`, it must be escaped with `\`). Multiple key-value pairs can be separated by commas `,`, e.g.:

    ```shell
    $ cjc --cfg "feature = lion, platform = dsp" source.cj
    ```

- Multiple `--cfg` options are allowed, e.g.:

    ```shell
    $ cjc --cfg "feature = lion" --cfg "platform = dsp" source.cj
    ```

- Defining the same condition variable multiple times is prohibited, e.g.:

    ```shell
    $ cjc --cfg "feature = lion" --cfg "feature = meta" source.cj
    ```

    ```shell
    $ cjc --cfg "feature = lion, feature = meta" source.cj
    ```

    Both commands will result in errors.

- If the option value does not contain `=` or contains an escaped `=`, it will be treated as the search path for the `cfg.toml` file, e.g.:

    ```shell
    $ cjc --cfg "./cfg" source.cj
    ```

    If `./cfg/cfg.toml` exists, the compiler will automatically read the custom conditions defined in it. The `cfg.toml` file should contain key-value pairs, with each pair on a separate line. Keys must be valid Cangjie identifiers, and values must be double-quoted strings (no escape sequences). Full-line and inline comments are supported, e.g.:

    ```toml
    feature = "lion"
    platform = "dsp"
    # Full-line comment
    feature = "meta" # Inline comment
    ```

- When multiple `--cfg` options specify `cfg.toml` search paths, the compiler searches in the specified order. If no `cfg.toml` is found, it searches in the default path.

- If any `--cfg` option directly provides key-value pairs, the `cfg.toml` file will be ignored.

- Without `--cfg`, the compiler searches for `cfg.toml` in the default path (the `package` directory specified by `--package` or `-p`, or the `cjc` execution directory).

## Multi-Condition Compilation

Cangjie allows developers to freely combine multiple conditional compilation options. Logical operators and parentheses are supported for defining precedence.

Usage example:

<!-- run -->
<!-- cfg="--cfg='feature=lion'" -->

```cangjie
//source.cj
@When[(test || feature == "lion") && !debug]
func fee() {
    println("feature lion")
main() {
    fee()
}
```

Compile and run the above code using the following command:

```shell
$ cjc --cfg="feature=lion" source.cj -o runner.out
```

The output will be:

```text
feature lion
```