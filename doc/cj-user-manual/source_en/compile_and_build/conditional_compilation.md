# Conditional Compilation

Developers can achieve conditional compilation through predefined or custom conditions. Currently, Cangjie supports conditional compilation for imports and declarations.

## Conditional Compilation for Imports and Declarations

Cangjie supports using the built-in compilation marker `@When` for conditional compilation. Compilation conditions are enclosed in `[]`, which can contain one or multiple sets of compilation conditions. `@When` can be applied to import nodes and declaration nodes (except `package`).

### Usage Example

Taking the built-in `os` compilation condition as an example, the usage is as follows:

<!-- run -->

```cangjie
@When[os == "Linux"]
class mc{}

main(): Int64 {
    var a = mc()
    return 0
}
```

In the above code, developers can successfully compile and execute it in `Linux` systems; in `non-Linux` systems, they will encounter a compilation error indicating that the `mc` class definition cannot be found.

Notably:

- Cangjie does not support nested compilation conditions. The following syntax is not allowed:

    ```cangjie
    @When[os == "Windows"]
    @When[os == "Linux"]    // Error, illegal nested when conditional compilation
    import std.ast.*
    @When[os == "Windows"]
    @When[os == "Linux"]    // Error, illegal nested when conditional compilation
    func A(){}
    ```

- `@When[...]` is a built-in compilation marker processed before imports. Code generated by macro expansion containing `@When[...]` will result in a compilation error, such as:

    ```cangjie
    @M0                     // macro which returns the input
    @When[os == "Linux"]    // Error, unexpected when conditional compilation directive
    func A(){}
    ```

## Built-in Compilation Condition Variables

Cangjie provides the following built-in condition variables: `os`, `backend`, `arch`, `cjc_version`, `debug`, and `test`.

### os

`os` represents the target platform's operating system. `os` supports the `==` and `!=` operators. Supported operating systems include: `Windows`, `Linux`, `macOS`.

Usage example:

<!-- run -->

```cangjie
@When[os == "Linux"]
func foo() {
    print("Linux, ")
}
@When[os == "Windows"]
func foo() {
    print("Windows, ")
}
@When[os != "Windows"]
func fee() {
    println("NOT Windows")
}
@When[os != "Linux"]
func fee() {
    println("NOT Linux")
}
main() {
    foo()
    fee()
}
```

When compiled and executed in a `Windows` environment, the output will be `Windows, NOT Linux`; in a `Linux` environment, it will be `Linux, NOT Windows`.

### backend

`backend` represents the target platform's backend type, supporting conditional compilation for multiple backends. `backend` conditions support the `==` and `!=` operators.

Currently supported backends include: `cjnative`.

Usage example:

<!-- run -->

```cangjie
@When[backend == "cjnative"]
func foo() {
    print("cjnative backend")
}
@When[backend != "cjnative"]
func foo() {
    print("not cjnative backend")
}
main() {
    foo()
}
```

When compiled and executed with the `cjnative` backend release package, the output will be `cjnative backend`.

### arch

`arch` represents the target platform's processor architecture. `arch` conditions support the `==` and `!=` operators.

Supported processor architectures include: `x86_64`, `aarch64`.

Usage example:

<!-- run -->

```cangjie
@When[arch == "aarch64"]
var arch = "aarch64"

@When[arch == "x86_64"]
var arch = "x86_64"

main() {
    println(arch)
}
```

When compiled and executed on an `x86_64` architecture target platform, the output will be `x86_64`; on an `aarch64` architecture target platform, it will be `aarch64`.

### cjc_version

`cjc_version` is a built-in condition in Cangjie, allowing developers to select code for compilation based on the current Cangjie compiler version. `cjc_version` supports six operators: `==`, `!=`, `>`, `<`, `>=`, `<=`. The format is `xx.xx.xx`, where each `xx` supports 1-2 digits. The calculation rule involves padding (to 2 digits) for comparison, e.g., `0.18.8 < 0.18.11`, `0.18.8 == 0.18.08`.

Usage example:

<!-- run -->

```cangjie
@When[cjc_version == "0.18.6"]
func foo() {
    println("cjc_version equals 0.18.6")
}
@When[cjc_version != "0.18.6"]
func foo() {
    println("cjc_version is NOT equal to 0.18.6")
}
@When[cjc_version > "0.18.6"]
func fnn() {
    println("cjc_version is greater than 0.18.6")
}
@When[cjc_version <= "0.18.6"]
func fnn() {
    println("cjc_version is less than or equal to 0.18.6")
}
@When[cjc_version < "0.18.6"]
func fee() {
    println("cjc_version is less than 0.18.6")
}
@When[cjc_version >= "0.18.6"]
func fee() {
    println("cjc_version is greater than or equal to 0.18.6")
}
main() {
    foo()
    fnn()
    fee()
}
```

The output of the above code will vary depending on the `cjc` version.

### debug

`debug` indicates whether debug mode is enabled (i.e., the `-g` compilation option is turned on). It can be used to switch between debug and release versions during compilation. `debug` conditions only support the logical NOT operator (`!`).

Usage example:

<!-- run -->

```cangjie
@When[debug]
func foo() {
    println("debug")
}
@When[!debug]
func foo() {
    println("NOT debug")
}
main() {
    foo()
}
```

When compiled with `-g`, the output will be `cjc debug`; without `-g`, it will be `NOT debug`.

### test

`test` indicates whether the unit test option `--test` is enabled. `test` conditions only support the logical NOT operator (`!`). It can be used to distinguish test code from regular code.

Usage example:

<!-- run -->

```cangjie
@When[test]
@Test
class Tests {
    @TestCase
    public func case1(): Unit {
        @Expect("run", foo())
    }
}

func foo() {
    "run"
}

@When[!test]
main () {
    println(foo())
}
```

When compiled and executed with `--test`, the test results will be obtained. Without `--test`, the code will compile and run normally, outputting `run`.

## Custom Compilation Condition Variables

Cangjie allows developers to define custom compilation condition variables and values. Custom condition variables must be valid identifiers and cannot have the same names as built-in condition variables. Their values are string literals. Custom conditions support the `==` and `!=` operators. Unlike built-in condition variables, custom conditions require developers to define them either through the `--cfg` compilation option or in the configuration file `cfg.toml` during compilation.

### Configuring Custom Condition Variables

There are two ways to configure custom condition variables: directly configuring key-value pairs in compilation options or specifying key-value pairs in the configuration file.

Developers can use `--cfg <value>` to pass custom compilation condition variables to the compiler in key-value pair format or specify the search path for the configuration file `cfg.toml`.

- The option value must be enclosed in double quotes.

- If the option value contains `=`, it will be directly configured as a key-value pair (if the path contains `=`, it must be escaped with `\`). Multiple key-value pairs can be separated by commas `,`. For example:

    ```shell
    $ cjc --cfg "feature = lion, platform = dsp" source.cj
    ```

- Multiple `--cfg` compilation options can be used for configuration, e.g.:

    ```shell
    $ cjc --cfg "feature = lion" --cfg "platform = dsp" source.cj
    ```

- Defining the same condition variable multiple times is not allowed, e.g.:

    ```shell
    $ cjc --cfg "feature = lion" --cfg "feature = meta" source.cj
    ```

    ```shell
    $ cjc --cfg "feature = lion, feature = meta" source.cj
    ```

    Both compilation commands above will result in errors.

- If the option value does not contain `=` or contains an escaped `=`, the option value will be treated as the search path for the configuration file `cfg.toml` and passed to the compiler. For example:

    ```shell
    $ cjc --cfg "./cfg" source.cj
    ```

    If `./cfg` contains `cfg.toml`, the compiler will automatically retrieve the custom compilation conditions configured in `./cfg/cfg.toml` during compilation. The `cfg.toml` file should use key-value pairs to configure custom condition variables, with each key-value pair on a separate line. The key must be a valid Cangjie identifier, and the value must be a string enclosed in double quotes (no escape sequences are supported). The `cfg.toml` file also supports full-line and end-of-line comments, e.g.:

    ```toml
    feature = "lion"
    platform = "dsp"
    # Full-line comment
    feature = "meta" # End-of-line comment
    ```

- When using `--cfg` multiple times to specify the search path for `cfg.toml`, the compiler will search for `cfg.toml` in the order of the provided paths. If `cfg.toml` is not found in any of the specified paths, it will search for the configuration file `cfg.toml` in the default path.

- When using `--cfg` multiple times for configuration, if any configuration is done directly in key-value pair format, the configurations in `cfg.toml` will be ignored.

- If the `--cfg` compilation option is not used, the compiler will search for the configuration file `cfg.toml` in the default path (the `package` directory specified by `--package` or `-p`, or the `cjc` execution directory).

## Multi-Conditional Compilation

Cangjie's conditional compilation allows developers to freely combine multiple conditional compilation options. Logical operators can be used to combine conditions, and parentheses can be used to clarify precedence.

Usage example:

<!-- run -->
<!-- cfg="--cfg='feature=lion'" -->

```cangjie
//source.cj
@When[(test || feature == "lion") && !debug]
func fee() {
    println("feature lion")
}
main() {
    fee()
}
```

Compiling and running the above code with the following command:

```shell
$ cjc --cfg="feature=lion" source.cj -o runner.out
```

Will produce the following output:

```text
feature lion
```